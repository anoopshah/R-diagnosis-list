#' Creates an environment containing CDB files
#'
#' Extracts SNOMED CT concepts from appropriate places in the 
#' hierarchy to create a set of CDB files in an environment.
#' Uses WordNet and manual synonyms if available.
#'
#' @param SNOMED environment containing a SNOMED dictionary
#' @param TRANSITIVE transitive closure table, generated by
#'   createTransitive. It is regenerated if not provided.
#' @param WN WordNet data.table as returned by downloadWordnet
#'   containing WordNet data from appropriate
#'   categories, in the format: cat (character), wordnetId (integer64),
#'   synonyms (list), parents (list), adj (list)
#' @param MANUAL_SYNONYMS data.table with columns term1 and term2,
#'   containing additional exact synonyms or abbreviations
#' @param noisy whether to output status messages 
#' @return environment containing the following data tables: FINDINGS,
#'   QUAL, CAUSES, BODY, OTHERCAUSE, OTHERSEARCH, OVERLAP, TRANSITIVE
#' @export
#' @examples
#' #Not run
#' #data(MANUAL_SYNONYMS)
#' #WN <- downloadWordNet()
#' #D <- createCDB(WN = WN, MANUAL_SYNONYMS = MANUAL_SYNONYMS)
createCDB <- function(SNOMED = getSNOMED(), TRANSITIVE = NULL,
	WN = NULL, MANUAL_SYNONYMS = NULL, noisy = TRUE){
	# Returns an environment containing data.tables used for
	# generating decompositions 
	D <- new.env()

	#### USEFUL FUNCTIONS ####
	stopwords <- c('the', 'of', 'by', 'with', 'to', 'into', 'and', 'or',
		'both', 'at', 'as', 'and/or', 'in')
	s <- function(x) SNOMEDconcept(x, SNOMED = SNOMED)
	desc <- function(x, ...){
		descendants(x, SNOMED = SNOMED, TRANSITIVE = TRANSITIVE, ...)
	}
	anc <- function(x, ...){
		ancestors(x, SNOMED = SNOMED, TRANSITIVE = TRANSITIVE, ...)
	}
	init <- function(x){
		x <- desc(x)
		rbind(description(x, SNOMED = SNOMED, include_synonyms = TRUE)[
			type == 'Synonym', .(conceptId,
			term = std_term(term))],
			acronyms(x, SNOMED = SNOMED)[, .(conceptId,
			term = paste0(' ', term, ' '))])
	}

	#### CAUSES (NOT USING TRANSITIVE TABLE) ####
	if (noisy) message('Initialising causes.')
	CAUSES <- description(unique(
		SNOMED$RELATIONSHIP[typeId %in% s(
		c('Due to', 'Causative agent', 'After'))]$destinationId),
		SNOMED = SNOMED, include_synonyms = T)[type == 'Synonym',
		.(conceptId, term = std_term(term))]
	
	#### GENERATE TRANSITIVE TABLE ####
	if (is.null(TRANSITIVE)){
		if (noisy) message('Creating transitive closure table.')
		TRANSITIVE <- createTransitive(c(desc(
			c('Clinical finding', 'Qualifier value', 'Body structure'),
			include_self = TRUE), CAUSES$conceptId), SNOMED = SNOMED)
		if (noisy){
			message(paste0('Transitive closure table created, ',
				nrow(TRANSITIVE), ' rows.'))
		}
	}

	#### FINDINGS ####
	if (noisy) message('Initialising findings and qualifiers.')
	FINDINGS <- init('Clinical finding')

	QUAL <- init(c('Grades (qualifier value)',
		'Groups (qualifier value)', 'Levels (qualifier value)',
		'Scores (qualifier value)', 'Types (qualifier value)',
		'Classification system (qualifier value)',
		'Descriptor (qualifier value)', 'Finding value (qualifier value)',
		'Courses (qualifier value)',
		'General site descriptor (qualifier value)'))

	#### BODY STRUCTURES ####
	if (noisy) message('Initialising body structures.')
	BODY <- init('Body structure')

	# Remove 'entire', 'structure of', 'of' and 'the'
	strip_structure <- ' entire | structure of | structure | of the | of | the '
	BODY <- rbind(BODY, BODY[, .(conceptId,
		term = gsub(strip_structure, ' ',
		gsub(strip_structure, ' ', term)))])
	BODY <- BODY[!duplicated(BODY)]

	# Remove structure type (e.g. 'muscle structure' etc.) if a name is
	# unique (e.g. there is only one rectus femoris and it is a muscle)
	structure_types <- c(' muscle | skeletal muscle ', ' ligament ',
		' tendon ', ' bone | bone structure ', ' joint ', ' artery ' , ' vein ')
	structure_terms <- lapply(structure_types, function(structure_type){
		# Find concepts with structure
		ANCESTOR <- BODY[term %like% paste0('^(', structure_type, ')$')]
		if (nrow(ANCESTOR) > 0){
			if (noisy) message(paste0('Removing the words ',
				structure_type, ' where possible.'))
			TEMP <- BODY[term %like% structure_type &
				conceptId %in% desc(ANCESTOR$conceptId),
				.(conceptId, term = gsub(paste0(strip_structure, '|',
				structure_type), ' ', gsub(paste0(strip_structure, '|',
				structure_type), ' ', term)))]
			TEMP[!duplicated(TEMP)]
			TEMP
		} else {
			data.table(conceptId = bit64::as.integer64(0),
				term = character(0))
		}
	})
	setattr(structure_terms, 'names', structure_types)

	# For each structure types, we have a list of putative terms. 
	# Need to check if these are unique
	other_structure_terms <- lapply(structure_types, function(structure_type){
		# Find concepts with structure
		unique(unlist(lapply(
		structure_terms[setdiff(structure_types, structure_type)], function(x){
			x$term
		})))
	})
	setattr(other_structure_terms, 'names', structure_types)

	# Body parts without a structure
	body_ancestors <- BODY[term %like% paste0('^(',
		paste(structure_types, collapse = '|'), ')$')]$conceptId
	OTHER_BODY_PARTS <- BODY[!(conceptId %in% desc(body_ancestors))]

	unique_structure_terms <- lapply(structure_types, function(structure_type){
		TEMP <- structure_terms[[structure_type]]
		searchtext <- paste(setdiff(structure_types, structure_type),
			collapse = '|')
		exclude <- TEMP[(term %in% c(OTHER_BODY_PARTS$term,
			other_structure_terms[[structure_type]])) |
			(term %like% searchtext)]$conceptId
		# Exclude if term is ambiguous or has another structure type mentioned
		TEMP[!(conceptId %in% exclude), .(conceptId, term, structure_type)]
	})
	setattr(unique_structure_terms, 'names', structure_types)

	EXTRA_WITHOUT_STRUCTURE <- rbindlist(unique_structure_terms)
	BODY <- rbind(BODY, EXTRA_WITHOUT_STRUCTURE[, .(conceptId, term)])
	gc()

	#### ADDING WORDNET ADJECTIVES ####
	if (!is.null(WN)){
		if (noisy) message('Adding WordNet adjectives.')
		# Extra concepts for 
		# XXX of XXX --> XXX XXX (adjectival)
		# e.g. neck of femur --> femoral neck
		#      dissection of artery --> arterial dissection
		ADJ <- WN[, .(adj = adj[1][[1]]), by = .(wordnetId, cat)]
		ADJ[, adj := sub('[1-9]$', '', adj)]
		SYN <- WN[, .(syn = synonyms[1][[1]]), by = wordnetId]
		SYN[, syn := sub('[1-9]$', '', syn)]
		ADJ <- merge(ADJ, SYN, on = 'wordnetId',
			allow.cartesian = TRUE)[adj != syn, .(adj, syn, cat)]
		ADJ <- ADJ[!duplicated(ADJ)]

		# Body structures
		ADJBODY <- BODY[term %like% '^ ([[:alpha:]]+) of ([[:alpha:]]+) $']
		ADJBODY[, part := sub('^ ([[:alpha:]]+) of ([[:alpha:]]+) $',
			'\\1', term)]
		ADJBODY[, whole := sub('^ ([[:alpha:]]+) of ([[:alpha:]]+) $',
			'\\2', term)]

		TEMP <- merge(ADJBODY[, .(syn = whole, part, conceptId)],
			ADJ[cat %in% c('noun.body')], by = 'syn')
		if (nrow(TEMP) > 0){
			BODY <- rbind(BODY, TEMP[,
				.(conceptId, term = paste0(' ', adj, ' ', part, ' '))])
			if (noisy){
				message(paste0('Added ', nrow(TEMP),
					' adjectival phrases for body structures.'))
			}
			BODY <- BODY[!duplicated(BODY)]
		}

		# Findings
		ADJFINDINGS <- FINDINGS[
			term %like% '^ ([[:alpha:]]+) of ([[:alpha:]]+) $' & 
			!(term %like% ' (fear|risk|finding|observation) of ')]
		ADJFINDINGS[, part := sub('^ ([[:alpha:]]+) of ([[:alpha:]]+) $',
			'\\1', term)]
		ADJFINDINGS[, whole := sub('^ ([[:alpha:]]+) of ([[:alpha:]]+) $',
			'\\2', term)]

		TEMP <- merge(ADJFINDINGS[, .(syn = whole, part, conceptId)],
			ADJ[cat %in% c('noun.state', 'noun.process', 'noun.phenomenon')],
			by = 'syn')
		if (nrow(TEMP) > 0){
			FINDINGS <- rbind(FINDINGS, TEMP[,
				.(conceptId, term = paste0(' ', adj, ' ', part, ' '))])
			if (noisy){
				message(paste0('Added ', nrow(TEMP),
					' adjectival phrases for findings.'))
			}
			FINDINGS <- FINDINGS[!duplicated(FINDINGS)]
		}
		TEMP <- NULL
	}

	#### LATERALITY ####
	# Create a list of lateralised body structures
	if (noisy) message('Creating lists of lateralised structures.')
	left_structures <- relatedConcepts('Left', typeId = 'Laterality',
		reverse = TRUE, SNOMED = SNOMED)
	right_structures <- relatedConcepts('Right', typeId = 'Laterality',
		reverse = TRUE, SNOMED = SNOMED)
	lateralisable_structures <- relatedConcepts('Side', typeId = 'Laterality',
		reverse = TRUE, SNOMED = SNOMED)
	bilateral_structures <- intersect(left_structures, right_structures)

	# Create a laterality flag
	BODY_LATERALITY <- BODY[, .(conceptId)]
	BODY_LATERALITY <- BODY_LATERALITY[!duplicated(BODY_LATERALITY)]
	BODY_LATERALITY[, laterality := "No laterality"]
	BODY_LATERALITY[conceptId %in% lateralisable_structures,
		laterality := "Lateralisable"]
	BODY_LATERALITY[conceptId %in% left_structures, laterality := 'Left']
	BODY_LATERALITY[conceptId %in% right_structures, laterality := 'Right']
	BODY_LATERALITY[conceptId %in% bilateral_structures,
		laterality := 'Bilateral']

	# Severity codes as per FHIR valueset plus a few extra
	if (noisy) message('Creating severity and stage lists.')
	SEVERITY <- QUAL[conceptId %in% desc(c(
		'Degrees of severity (qualifier value)',
		'Severities (qualifier value)'))]
	QUAL <- QUAL[!(conceptId %in% SEVERITY$conceptId)]

	# Concepts for stage definition as per FHIR valueset with a few extra
	# from 'Stages' 
	STAGE <- desc(c('Stages', 'Tumour stage finding'))
	STAGE <- rbind(FINDINGS[conceptId %in% STAGE],
		QUAL[conceptId %in% STAGE])
	QUAL <- QUAL[!(conceptId %in% STAGE$conceptId)]
	
	# Laterality concepts
	D$latConcepts <- s(c('Left', 'Right', 'Bilateral'))
	setattr(D$latConcepts, 'names', c('Left', 'Right', 'Bilateral'))
	LATERALITY <- QUAL[conceptId %in% D$latConcepts]
	LATERALITY <- rbind(LATERALITY,
		data.table(conceptId = bit64::as.integer64('51440002'),
		term = ' left and right '))
	QUAL <- QUAL[!(conceptId %in% LATERALITY$conceptId)]
	QUAL <- QUAL[!(term %in% paste0(' ', stopwords, ' '))]

	#### PREPARE CDB ENVIRONMENT ####
	addmw <- function(X, wn_categories){
		if (!is.null(MANUAL_SYNONYMS)){
			M <- copy(as.data.table(MANUAL_SYNONYMS))
			M[, snomed := sub('^ *', ' ', sub(' *$', ' ', snomed))]
			M[, synonym := sub('^ *', ' ', sub(' *$', ' ', synonym))]
			X <- rbind(X,
				merge(X, M[, .(term = snomed, extra = synonym)],
				by = 'term')[, .(conceptId, term = extra)],
				merge(X, M[bidirectional == TRUE, .(term = synonym,
				extra = snomed)], by = 'term')[,
				.(conceptId, term = extra)], fill = TRUE)
		}
		if (!is.null(WN)){
			return(addWordNet(X, wn_categories = wn_categories, WN = WN,
				CHECK_TABLE <- rbind(QUAL, LATERALITY, FINDINGS,
				BODY, STAGE, CAUSES, SEVERITY)))
		} else {
			return(X[!duplicated(X)])
		}
	}
	D$FINDINGS <- addmw(FINDINGS, c('noun.state',
		'noun.process', 'noun.phenomenon'))
	D$QUAL <- addmw(QUAL, c('noun.state',
		'noun.process', 'noun.phenomenon'))
	D$CAUSES <- addmw(CAUSES, c('noun.state',
		'noun.process', 'noun.phenomenon', 'noun.animal', 'noun.plant'))
	D$BODY <- addmw(BODY, c('noun.body'))
	
	D$SEVERITY <- SEVERITY
	D$LATERALITY <- LATERALITY
	D$STAGE <- STAGE
	D$BODY_LATERALITY <- BODY_LATERALITY
	# Causes which are not other findings (may be events,
	#	substances or organisms) 
	D$OTHERCAUSE <- CAUSES[!(conceptId %in% FINDINGS$conceptId)]

	# OVERLAP = concepts that are in findings as well as another
	# (qual etc.)
	FindingsFSN <- description(FINDINGS$conceptId, SNOMED = SNOMED)[,
		.(findingId = conceptId, term = sub(' \\([^\\(]+\\)$', '', term))]
	OtherFSN <- description(c(QUAL$conceptId, BODY$conceptId),
		SNOMED = SNOMED)[,
		.(otherId = conceptId, term = sub(' \\([^\\(]+\\)$', '', term))]
	D$OVERLAP <- merge(FindingsFSN, OtherFSN)[, .(findingId, otherId)]
	D$OVERLAP <- D$OVERLAP[!duplicated(D$OVERLAP)]

	D$TRANSITIVE <- TRANSITIVE
	D$metadata <- SNOMED$metadata
	
	D$SCT_assoc <- s('Associated with')
	D$SCT_cause <- s('Causative agent')
	D$SCT_after <- s('After')
	D$SCT_dueto <- s('Due to')
	D$SCT_findingsite <- s('Finding site')
	D$SCT_disorder <- s('Disorder')
	D$SCT_finding <- s('Clinical finding')
	D$allergyConcepts <- s(c('Allergic disposition',
		'Intolerance to substance', 'Hypersensitivity disposition'))
	D$stopwords <- c('the', 'of', 'by', 'with', 'to', 'into', 'and', 'or',
		'both', 'at', 'as', 'and/or')
	D$SEMTYPE <- rbind(
		CDB$FINDINGS[, .(conceptId, semType = 'finding')],
		CDB$BODY[, .(conceptId, semType = 'body')],
		CDB$QUAL[, .(conceptId, semType = 'qualifier')],
		CDB$LATERALITY[, .(conceptId, semType = 'laterality')],
		CDB$SEVERITY[, .(conceptId, semType = 'severity')])
	setkey(D$SEMTYPE, conceptId)
	D$SEMTYPE[!duplicated(D$SEMTYPE)]
	# D$DISAMBIG <- createDisambiguationTrainer(CDB, SNOMED)
	return(D)
}

createDisambiguationTrainer <- function(CDB, SNOMED){
	# Create disambiguation trainer by using SNOMED concepts containing
	# 'Clinical finding', 'Qualifier value', 'Body structure'
	# Output a data.table table text,p with {p ...} surrounding the
	# acronym, which can be converted to MedCAT training data
	
	# TO BE WRITTEN
	
	
}

# Internal function: for a standardised form of words for use in CDB
std_term <- function(x, stopwords = c('the', 'of', 'by', 'with', 'to',
	'into', 'and', 'or', 'both', 'at', 'as', 'and/or', 'in')){
	# lowercase except if single word concepts with second, third
	# or final letter upper case (i.e. an acronym like HbA1c or
	# nSTEMI)
	# decapitalise the first letter if rest of first word is 
	# lower case and non-numeric, otherwise keep case as is.
	x <- gsub(' +', ' ', gsub('^ *|-|,|\\(|\\)| *$', '', x))
	#paste0(' ', ifelse(nchar(gsub('[^ ]', '', x)) > 0, tolower(x),
	#	ifelse(x %like% '[A-Z]$|^.[A-Z]|^..[A-Z]', x, tolower(x))), ' ')
	words <- strsplit(x, ' ')
	paste0(' ', sapply(lapply(words, function(y){
		ifelse(y %like% '^[A-Z][a-z]+$' |
			y %in% toupper(stopwords), tolower(y), y)
	}), function(y) paste(y, collapse = ' ')), ' ')
}
#std_term('HbA1c') = ' HbA1c '
#std_term('nSTEMI') = ' nSTEMI '
#std_term('Fever') = ' fever '
#std_term('MCA stroke') = ' MCA stroke '
