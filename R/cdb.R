#' Creates an environment containing CDB files
#'
#' Extracts SNOMED CT concepts from appropriate places in the 
#' hierarchy to create a set of CDB files in an environment.
#' Uses WordNet and manual synonyms if available.
#'
#' @param SNOMED environment containing a SNOMED dictionary
#' @param TRANSITIVE transitive closure table, generated by
#'   createTransitive. It is regenerated if not provided.
#' @param WN WordNet data.table as returned by downloadWordnet
#'   containing WordNet data from appropriate
#'   categories, in the format: cat (character), wordnetId (integer64),
#'   synonyms (list), parents (list), adj (list)
#' @param MANUAL_SYNONYMS data.table with columns term1 and term2,
#'   containing additional exact synonyms or abbreviations
#' @param noisy whether to output status messages 
#' @return environment containing the following data tables: FINDINGS,
#'   QUAL, CAUSES, BODY, ORGSUB, OTHERSEARCH, OVERLAP, TRANSITIVE
#' @export
#' @examples
#' #Not run
#' #data(MANUAL_SYNONYMS)
#' #WN <- downloadWordnet()
#' #D <- createCDB(WN = WN, MANUAL_SYNONYMS = MANUAL_SYNONYMS)
createCDB <- function(SNOMED = getSNOMED(), TRANSITIVE = NULL,
	WN = NULL, MANUAL_SYNONYMS = NULL, noisy = TRUE){
	# Returns an environment containing data.tables used for
	# generating decompositions 
	D <- new.env()

	#### USEFUL FUNCTIONS ####
	s <- function(x) SNOMEDconcept(x, SNOMED = SNOMED)
	desc <- function(x, ...){
		descendants(x, SNOMED = SNOMED, TRANSITIVE = TRANSITIVE, ...)
	}
	anc <- function(x, ...){
		ancestors(x, SNOMED = SNOMED, TRANSITIVE = TRANSITIVE, ...)
	}
	init <- function(x){
		x <- desc(x)
		rbind(description(x, SNOMED = SNOMED, include_synonyms = TRUE)[
			type == 'Synonym', .(conceptId,
			term = paste0(' ', tolower(term), ' '))],
			acronyms(x, SNOMED = SNOMED)[, .(conceptId,
			term = paste0(' ', term, ' '))])
	}

	#### CAUSES (NOT USING TRANSITIVE TABLE) ####
	if (noisy) message('Initialising causes.')
	CAUSES <- description(unique(
		SNOMED$RELATIONSHIP[typeId %in% s(
		c('Due to', 'Causative agent', 'After'))]$destinationId),
		SNOMED = SNOMED, include_synonyms = T)[type == 'Synonym',
		.(conceptId, term = paste0(' ', tolower(term), ' '))]
	
	#### GENERATE TRANSITIVE TABLE ####
	if (is.null(TRANSITIVE)){
		if (noisy) message('Creating transitive closure table.')
		TRANSITIVE <- createTransitive(c(desc(
			c('Clinical finding', 'Qualifier value', 'Body structure'),
			include_self = TRUE), CAUSES$conceptId), SNOMED = SNOMED)
		if (noisy){
			message(paste0('Transitive closure table created, ',
				nrow(TRANSITIVE), ' rows.'))
		}
	}

	#### FINDINGS ####
	if (noisy) message('Initialising findings and qualifiers.')
	FINDINGS <- init('Clinical finding')

	QUAL <- init(c('Grades (qualifier value)',
		'Groups (qualifier value)', 'Levels (qualifier value)',
		'Scores (qualifier value)', 'Types (qualifier value)',
		'Classification system (qualifier value)',
		'Descriptor (qualifier value)', 'Finding value (qualifier value)',
		'Courses (qualifier value)',
		'General site descriptor (qualifier value)'))

	#### BODY STRUCTURES ####
	if (noisy) message('Initialising body structures.')
	BODY <- init('Body structure')

	# Remove 'entire', 'structure of', 'of' and 'the'
	strip_structure <- ' entire | structure of | structure | of the | of | the '
	BODY <- rbind(BODY, BODY[, .(conceptId,
		term = gsub(strip_structure, ' ',
		gsub(strip_structure, ' ', term)))])
	BODY <- BODY[!duplicated(BODY)]

	# Remove structure type (e.g. 'muscle structure' etc.) if a name is
	# unique (e.g. there is only one rectus femoris and it is a muscle)
	structure_types <- c(' muscle | skeletal muscle ', ' ligament ',
		' tendon ', ' bone | bone structure ', ' joint ', ' artery ' , ' vein ')
	structure_terms <- lapply(structure_types, function(structure_type){
		# Find concepts with structure
		ANCESTOR <- BODY[term %like% paste0('^(', structure_type, ')$')]
		TEMP <- BODY[term %like% structure_type &
			conceptId %in% desc(ANCESTOR$conceptId),
			.(conceptId, term = gsub(paste0(strip_structure, '|',
			structure_type), ' ', gsub(paste0(strip_structure, '|',
			structure_type), ' ', term)))]
		TEMP[!duplicated(TEMP)]
		TEMP
	})
	setattr(structure_terms, 'names', structure_types)

	# For each structure types, we have a list of putative terms. 
	# Need to check if these are unique
	other_structure_terms <- lapply(structure_types, function(structure_type){
		# Find concepts with structure
		unique(unlist(lapply(
		structure_terms[setdiff(structure_types, structure_type)], function(x){
			x$term
		})))
	})
	setattr(other_structure_terms, 'names', structure_types)

	# Body parts without a structure
	body_ancestors <- BODY[term %like% paste0('^(',
		paste(structure_types, collapse = '|'), ')$')]$conceptId
	OTHER_BODY_PARTS <- BODY[!(conceptId %in% desc(body_ancestors))]

	unique_structure_terms <- lapply(structure_types, function(structure_type){
		TEMP <- structure_terms[[structure_type]]
		searchtext <- paste(setdiff(structure_types, structure_type),
			collapse = '|')
		exclude <- TEMP[(term %in% c(OTHER_BODY_PARTS$term,
			other_structure_terms[[structure_type]])) |
			(term %like% searchtext)]$conceptId
		# Exclude if term is ambiguous or has another structure type mentioned
		TEMP[!(conceptId %in% exclude), .(conceptId, term, structure_type)]
	})
	setattr(unique_structure_terms, 'names', structure_types)

	EXTRA_WITHOUT_STRUCTURE <- rbindlist(unique_structure_terms)
	BODY <- rbind(BODY, EXTRA_WITHOUT_STRUCTURE[, .(conceptId, term)])
	gc()

	#### ADDING WORDNET ADJECTIVES ####
	if (!is.null(WN)){
		if (noisy) message('Adding WordNet adjectives.')
		# Extra concepts for 
		# XXX of XXX --> XXX XXX (adjectival)
		# e.g. neck of femur --> femoral neck
		#      dissection of artery --> arterial dissection
		ADJ <- WN[, .(adj = adj[1][[1]]), by = .(wordnetId, cat)]
		ADJ[, adj := sub('[1-9]$', '', adj)]
		SYN <- WN[, .(syn = synonyms[1][[1]]), by = wordnetId]
		SYN[, syn := sub('[1-9]$', '', syn)]
		ADJ <- merge(ADJ, SYN, on = 'wordnetId',
			allow.cartesian = TRUE)[adj != syn, .(adj, syn, cat)]
		ADJ <- ADJ[!duplicated(ADJ)]

		# Body structures
		ADJBODY <- BODY[term %like% '^ ([[:alpha:]]+) of ([[:alpha:]]+) $']
		ADJBODY[, part := sub('^ ([[:alpha:]]+) of ([[:alpha:]]+) $',
			'\\1', term)]
		ADJBODY[, whole := sub('^ ([[:alpha:]]+) of ([[:alpha:]]+) $',
			'\\2', term)]

		TEMP <- merge(ADJBODY[, .(syn = whole, part, conceptId)],
			ADJ[cat %in% c('noun.body')], by = 'syn')
		if (nrow(TEMP) > 0){
			BODY <- rbind(BODY, TEMP[,
				.(conceptId, term = paste0(' ', adj, ' ', part, ' '))])
			if (noisy){
				message(paste0('Added ', nrow(TEMP),
					' adjectival phrases for body structures.'))
			}
			BODY <- BODY[!duplicated(BODY)]
		}

		# Findings
		ADJFINDINGS <- FINDINGS[
			term %like% '^ ([[:alpha:]]+) of ([[:alpha:]]+) $' & 
			!(term %like% ' (fear|risk|finding|observation) of ')]
		ADJFINDINGS[, part := sub('^ ([[:alpha:]]+) of ([[:alpha:]]+) $',
			'\\1', term)]
		ADJFINDINGS[, whole := sub('^ ([[:alpha:]]+) of ([[:alpha:]]+) $',
			'\\2', term)]

		TEMP <- merge(ADJFINDINGS[, .(syn = whole, part, conceptId)],
			ADJ[cat %in% c('noun.state', 'noun.process', 'noun.phenomenon')],
			by = 'syn')
		if (nrow(TEMP) > 0){
			FINDINGS <- rbind(FINDINGS, TEMP[,
				.(conceptId, term = paste0(' ', adj, ' ', part, ' '))])
			if (noisy){
				message(paste0('Added ', nrow(TEMP),
					' adjectival phrases for findings.'))
			}
			FINDINGS <- FINDINGS[!duplicated(FINDINGS)]
		}
		TEMP <- NULL
	}

	#### LATERALITY ####
	# Create a list of lateralised body structures
	if (noisy) message('Creating lists of lateralised structures.')
	left_structures <- relatedConcepts('Left', typeId = 'Laterality',
		reverse = TRUE, SNOMED = SNOMED)
	right_structures <- relatedConcepts('Right', typeId = 'Laterality',
		reverse = TRUE, SNOMED = SNOMED)
	lateralisable_structures <- relatedConcepts('Side', typeId = 'Laterality',
		reverse = TRUE, SNOMED = SNOMED)
	bilateral_structures <- intersect(left_structures, right_structures)

	# Create a laterality flag
	BODY_LATERALITY <- BODY[, .(conceptId)]
	BODY_LATERALITY <- BODY_LATERALITY[!duplicated(BODY_LATERALITY)]
	BODY_LATERALITY[, laterality := "No laterality"]
	BODY_LATERALITY[conceptId %in% lateralisable_structures,
		laterality := "Lateralisable"]
	BODY_LATERALITY[conceptId %in% left_structures, laterality := 'Left']
	BODY_LATERALITY[conceptId %in% right_structures, laterality := 'Right']
	BODY_LATERALITY[conceptId %in% bilateral_structures,
		laterality := 'Bilateral']

	# Severity codes as per FHIR valueset plus a few extra
	if (noisy) message('Creating severity and stage lists.')
	SEVERITY <- QUAL[conceptId %in% desc(c(
		'Degrees of severity (qualifier value)',
		'Severities (qualifier value)'))]
	QUAL <- QUAL[!(conceptId %in% SEVERITY$conceptId)]

	# Concepts for stage definition as per FHIR valueset with a few extra
	# from 'Stages' 
	STAGE <- desc(c('Stages', 'Tumour stage finding'))
	STAGE <- rbind(FINDINGS[conceptId %in% STAGE],
		QUAL[conceptId %in% STAGE])
	QUAL <- QUAL[!(conceptId %in% STAGE$conceptId)]

	LATERALITY <- QUAL[conceptId %in% desc('Side (qualifier value)')]
	# Extra snynonym abbreviations
	LATERALITY <- rbind(LATERALITY,
		data.table(conceptId = bit64::as.integer64('51440002'),
		term = ' left and right '))
	QUAL <- QUAL[!(conceptId %in% LATERALITY$conceptId)]
	
	stopwords <- c('the', 'of', 'by', 'with', 'to', 'into', 'and', 'or',
		'both', 'at', 'as', 'and/or')
	QUAL <- QUAL[!(term %in% paste0(' ', stopwords, ' '))]

	#### PREPARE CDB ENVIRONMENT ####
	addmw <- function(X, wn_categories){
		if (!is.null(MANUAL_SYNONYMS)){
			M <- as.data.table(MANUAL_SYNONYMS)
			M[, term1 := sub('^ *', ' ', sub(' *$', ' ', term1))]
			M[, term2 := sub('^ *', ' ', sub(' *$', ' ', term2))]
			X <- rbind(X,
				merge(X, M[, .(term = term1, extra = term2)],
				by = 'term')[, .(conceptId, term = extra)],
				merge(X, M[, .(term = term2, extra = term1)],
				by = 'term')[, .(conceptId, term = extra)], fill = TRUE)
		}
		if (!is.null(WN)){
			addWordNet(X, wn_categories = wn_categories, WN = WN)
		} else {
			X[!duplicated(X)]
		}
	}
	D$FINDINGS <- addmw(FINDINGS, c('noun.state',
		'noun.process', 'noun.phenomenon'))
	D$QUAL <- addmw(QUAL, c('noun.state',
		'noun.process', 'noun.phenomenon'))
	D$CAUSES <- addmw(CAUSES, c('noun.state',
		'noun.process', 'noun.phenomenon', 'noun.animal', 'noun.plant'))
	D$BODY <- addmw(BODY, c('noun.body'))
	
	D$ORGSUB <- CAUSES[conceptId %in% union(desc('Substance'),
		desc('Organism'))]
	OTHERSEARCH <- rbind(QUAL, FINDINGS, CAUSES, BODY, fill = TRUE)
	D$OTHERSEARCH <- OTHERSEARCH[!duplicated(OTHERSEARCH)]
	
	# OVERLAP = concepts that are in findings as well as another
	# (qual etc.)
	FindingsFSN <- description(FINDINGS$conceptId, SNOMED = SNOMED)[,
		.(findingId = conceptId, term = sub(' \\([^\\(]+\\)$', '', term))]
	OtherFSN <- description(c(QUAL$conceptId, BODY$conceptId),
		SNOMED = SNOMED)[,
		.(otherId = conceptId, term = sub(' \\([^\\(]+\\)$', '', term))]
	D$OVERLAP <- merge(FindingsFSN, OtherFSN)[, .(findingId, otherId)]
	D$OVERLAP <- D$OVERLAP[!duplicated(D$OVERLAP)]

	D$TRANSITIVE <- TRANSITIVE
	D$metadata <- SNOMED$metadata
	return(D)
}
